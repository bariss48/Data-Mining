import picklewith open('FIMresults','rb') as f:    frequentItemsets, Supports, SingleItems, database = pickle.load(f)import numpy as npfrom itertools import combinationsdef ShowDatabase(database, SingleItems):    for i in range(database.shape[0]):        tr = database[i,:]        I = np.nonzero(tr>0)[0]        print(i, ':', SingleItems[I])    returndef FindIndex(itemset, frequentItemsets):    I = []    for k in range(0,len(frequentItemsets)):        tmp = frequentItemsets[k]        if tmp.shape[0] == itemset.shape[0]:            if all(itemset == tmp):                I = k                break    return INumOfTrans = database.shape[0]Supports = [support / NumOfTrans for support in Supports]ShowDatabase(database, SingleItems)minConf = 0.9minKulc = 0.3for itemset in frequentItemsets:    L = itemset.shape[0]    if 1 < L:        I = FindIndex(itemset, frequentItemsets)        suppItemset = Supports[I]                for j in range(1,L):            cmbn = list(combinations(np.arange(0,L),j))            cmbn = np.matrix(cmbn)                        for k in range(0,len(cmbn)):                premiseIndex = np.array(cmbn[k,:])[0]                tmp = np.ones(L, dtype='int8')                tmp[premiseIndex] = 0                consequentIndex = np.nonzero(tmp != 0)[0]                premise = itemset[premiseIndex]                consequent = itemset[consequentIndex]                                tmpPremise = ''                for kk in range(0, np.size(premise)):                    tmpPremise = tmpPremise + SingleItems[premise[kk]]                                tmpConsequent = ''                for kk in range(0, np.size(consequent)):                    tmpConsequent = tmpConsequent + SingleItems[consequent[kk]]                                    I = FindIndex(premise, frequentItemsets)                suppPremise = Supports[I]                conf = suppItemset / suppPremise                                I = FindIndex(consequent, frequentItemsets)                suppConsequent = Supports[I]                                kulc = 0.5* (suppItemset/suppPremise + suppItemset/suppConsequent)                kulc = 2* (kulc - 0.5)                                if minKulc <= kulc:                    if minConf <= conf:                        print(tmpPremise, "-->", tmpConsequent, "C:", conf, "Kulc:", kulc)